#### 分析

1. 添加哑节点
2. 遍历链表，整理前缀和字典，$key$是和，值是第一个前缀和是$key$的$id$
3. 当有两个不同的$id$的和相等时，`(id1, id2]`之间的结点就可以删除了
    ```C
    例如：id:  0  1  2  3  4  5
          val: 0  1  2  3 -3 -2
          sum: 0  1  3  6  3  1
          key  value
          0    0
          1    1
          3    2
          6    3
    ```
    当遍历到倒数第2个结点时，前缀和是3，而3已经在前缀和字典中了，那么这一段节点就可以删除了
    `0  1  2  3 -3 -2` -->  `0  1  2 -2`
4. 重复2 3两个步骤，直至不存在连续和为0的区间段

上面的算法或许可以这样优化，但是没想好怎样快速的“合并区间”，就没有去实现
1. 添加哑节点
2. 遍历链表，整理前缀和字典，$key$是和，值是第一个以及最后一个前缀和是$key$的$id$
    ```C
    例如：id:  0  1  2  3  4  5
          val: 0  1  2  3 -3 -2
          sum: 0  1  3  6  3  1
          key  value
          0    [0, 0]
          1    [1, 5]
          3    [2, 4]
          6    [3, 3]
    ```
3. 当有两个不同的$id$的和相等时，`(id1, id2]`之间的结点就可以删除了
    这里可以考虑将多个可删除的区间进行整理，例如：
        - 当然如果多组不重合的，是可以一并删除的
        - 如果两组之间有重合，这里取范围更大的一组，范围一样大，就取更靠前的一组
4. 重复2 3两个步骤，直至不存在连续和为0的区间段
