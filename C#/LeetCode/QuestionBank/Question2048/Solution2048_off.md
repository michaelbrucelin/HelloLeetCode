### [下一个更大的数值平衡数](https://leetcode.cn/problems/next-greater-numerically-balanced-number/solutions/2555817/xia-yi-ge-geng-da-de-shu-zhi-ping-heng-s-rm9d/)

#### 方法一：枚举

**思路与算法**

题目给一个整数 $n$ ，要求返回严格大于 $n$ 的最小数值平衡数，我们直接按照题目的要求进行模拟即可。

观察到 $0 <= n <= 10^6$, 我们可能返回的数值平衡数最大是 $1224444$，这个范围可以在时间要求内找到答案。

我们依次枚举大于 $n$ 的整数，统计所有数字的出现频数，判断是否是数值平衡数即可。

**代码**

```cpp
class Solution {
public:
    bool isBalance(int x) {
        vector<int> count(10);
        while (x > 0) {
            count[x % 10]++;
            x /= 10;
        }
        for (int d = 0; d < 10; ++d) {
            if (count[d] > 0 && count[d] != d) {
                return false;
            }
        }
        return true;
    }

    int nextBeautifulNumber(int n) {
        for (int i = n + 1; i <= 1224444; ++i) {
            if (isBalance(i)) {
                return i;
            }
        }
        return -1;
    }
};
```

```java
class Solution {
    public int nextBeautifulNumber(int n) {
        for (int i = n + 1; i <= 1224444; ++i) {
            if (isBalance(i)) {
                return i;
            }
        }
        return -1;
    }

    private boolean isBalance(int x) {
        int[] count = new int[10];
        while (x > 0) {
            count[x % 10]++;
            x /= 10;
        }
        for (int d = 0; d < 10; ++d) {
            if (count[d] > 0 && count[d] != d) {
                return false;
            }
        }
        return true;
    }
}
```

```python
class Solution:
    def nextBeautifulNumber(self, n: int) -> int:
        for i in range(n + 1, 1224445):
            count = Counter(str(i))
            if all(count[d] == int(d) for d in count):
                return i
```

```javascript
function isBalance(x) {
    const count = new Array(10).fill(0);
    while (x > 0) {
        count[x % 10]++;
        x = Math.floor(x / 10);
    }
    for (let d = 0; d < 10; d++) {
        if (count[d] > 0 && count[d] != d) {
            return false;
        }
    }
    return true;
}

var nextBeautifulNumber = function(n) {
    for (let i = n + 1; i <= 1224444; i++) {
        if (isBalance(i)) {
            return i;
        }
    }
};
```

```go
func isBalance(x int) bool {
    count := make([]int, 10)
    for x > 0 {
        count[x % 10]++
        x /= 10
    }
    for i := 0; i < 10; i++ {
        if count[i] > 0 && count[i] != i {
            return false
        }
    }
    return true
}

func nextBeautifulNumber(n int) int {
    for i := n + 1; i <= 1224444; i++ {
        if isBalance(i) {
            return i
        }
    }
    return -1
}
```

```c
int isBalance(int x) {
    int count[10] = {0};
    while (x > 0) {
        count[x % 10]++;
        x /= 10;
    }
    for (int i = 0; i < 10; i++) {
        if (count[i] > 0 && count[i] != i) {
            return 0;
        }
    }
    return 1;
}

int nextBeautifulNumber(int n) {
    for (int i = n + 1; i <= 1224444; i++) {
        if (isBalance(i)) {
            return i;
        }
    }
    return -1;
}
```

```csharp
public class Solution {
    public int NextBeautifulNumber(int n) {
        for (int i = n + 1; i <= 1224444; i++) {
            if (IsBalance(i)) {
                return i;
            }
        }
        return -1;
    }

    private bool IsBalance(int x) {
        int[] count = new int[10];
        while (x > 0) {
            count[x % 10]++;
            x /= 10;
        }
        for (int i = 0; i < 10; i++) {
            if (count[i] > 0 && count[i] != i) {
                return false;
            }
        }
        return true;
    }
}
```

**复杂度分析**

-   时间复杂度：$O(C - n)$，其中 $C = 1224444$ 是可能为答案的最大的数值平衡数，取决于题目的数据范围。
-   空间复杂度：$O(1)$。

#### 方法二：打表 + 二分

**思路与算法**

利用方法一的代码，记录下所有的数值平衡数。

再根据输入，二分查找第一个严格大于 $n$ 的数值平衡数。

**代码**

```cpp
class Solution {
public:
    const vector<int> balance {
        1, 22, 122, 212, 221, 333, 1333, 3133, 3313, 3331, 4444,
        14444, 22333, 23233, 23323, 23332, 32233, 32323, 32332,
        33223, 33232, 33322, 41444, 44144, 44414, 44441, 55555,
        122333, 123233, 123323, 123332, 132233, 132323, 132332,
        133223, 133232, 133322, 155555, 212333, 213233, 213323,
        213332, 221333, 223133, 223313, 223331, 224444, 231233,
        231323, 231332, 232133, 232313, 232331, 233123, 233132,
        233213, 233231, 233312, 233321, 242444, 244244, 244424,
        244442, 312233, 312323, 312332, 313223, 313232, 313322,
        321233, 321323, 321332, 322133, 322313, 322331, 323123,
        323132, 323213, 323231, 323312, 323321, 331223, 331232,
        331322, 332123, 332132, 332213, 332231, 332312, 332321,
        333122, 333212, 333221, 422444, 424244, 424424, 424442,
        442244, 442424, 442442, 444224, 444242, 444422, 515555,
        551555, 555155, 555515, 555551, 666666, 1224444
    };

    int nextBeautifulNumber(int n) {
        return *upper_bound(balance.begin(), balance.end(), n);
    }
};
```

```java
class Solution {
    private static final int[] balance = new int[] {
        1, 22, 122, 212, 221, 333, 1333, 3133, 3313, 3331, 4444,
        14444, 22333, 23233, 23323, 23332, 32233, 32323, 32332,
        33223, 33232, 33322, 41444, 44144, 44414, 44441, 55555,
        122333, 123233, 123323, 123332, 132233, 132323, 132332,
        133223, 133232, 133322, 155555, 212333, 213233, 213323,
        213332, 221333, 223133, 223313, 223331, 224444, 231233,
        231323, 231332, 232133, 232313, 232331, 233123, 233132,
        233213, 233231, 233312, 233321, 242444, 244244, 244424,
        244442, 312233, 312323, 312332, 313223, 313232, 313322,
        321233, 321323, 321332, 322133, 322313, 322331, 323123,
        323132, 323213, 323231, 323312, 323321, 331223, 331232,
        331322, 332123, 332132, 332213, 332231, 332312, 332321,
        333122, 333212, 333221, 422444, 424244, 424424, 424442,
        442244, 442424, 442442, 444224, 444242, 444422, 515555,
        551555, 555155, 555515, 555551, 666666, 1224444
    };

    public int nextBeautifulNumber(int n) {
        int i = Arrays.binarySearch(balance, n + 1);
        if (i < 0) {
            i = -i - 1;
        }
        return balance[i];
    }
}
```

```python
balance = [
    1, 22, 122, 212, 221, 333, 1333, 3133, 3313, 3331, 4444,
    14444, 22333, 23233, 23323, 23332, 32233, 32323, 32332,
    33223, 33232, 33322, 41444, 44144, 44414, 44441, 55555,
    122333, 123233, 123323, 123332, 132233, 132323, 132332,
    133223, 133232, 133322, 155555, 212333, 213233, 213323,
    213332, 221333, 223133, 223313, 223331, 224444, 231233,
    231323, 231332, 232133, 232313, 232331, 233123, 233132,
    233213, 233231, 233312, 233321, 242444, 244244, 244424,
    244442, 312233, 312323, 312332, 313223, 313232, 313322,
    321233, 321323, 321332, 322133, 322313, 322331, 323123,
    323132, 323213, 323231, 323312, 323321, 331223, 331232,
    331322, 332123, 332132, 332213, 332231, 332312, 332321,
    333122, 333212, 333221, 422444, 424244, 424424, 424442,
    442244, 442424, 442442, 444224, 444242, 444422, 515555,
    551555, 555155, 555515, 555551, 666666, 1224444
]

class Solution:
    def nextBeautifulNumber(self, n: int) -> int:
        return balance[bisect_right(balance, n)]
```

```javascript
const balance = [
    1, 22, 122, 212, 221, 333, 1333, 3133, 3313, 3331, 4444,
    14444, 22333, 23233, 23323, 23332, 32233, 32323, 32332,
    33223, 33232, 33322, 41444, 44144, 44414, 44441, 55555,
    122333, 123233, 123323, 123332, 132233, 132323, 132332,
    133223, 133232, 133322, 155555, 212333, 213233, 213323,
    213332, 221333, 223133, 223313, 223331, 224444, 231233,
    231323, 231332, 232133, 232313, 232331, 233123, 233132,
    233213, 233231, 233312, 233321, 242444, 244244, 244424,
    244442, 312233, 312323, 312332, 313223, 313232, 313322,
    321233, 321323, 321332, 322133, 322313, 322331, 323123,
    323132, 323213, 323231, 323312, 323321, 331223, 331232,
    331322, 332123, 332132, 332213, 332231, 332312, 332321,
    333122, 333212, 333221, 422444, 424244, 424424, 424442,
    442244, 442424, 442442, 444224, 444242, 444422, 515555,
    551555, 555155, 555515, 555551, 666666, 1224444
];

var nextBeautifulNumber = function(n) {
    let left = 0, right = balance.length - 1;
    while (left < right) {
        let mid = (left + right) >> 1;
        if (balance[mid] <= n) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return balance[left];
};
```

```go
var balance = []int{
    1, 22, 122, 212, 221, 333, 1333, 3133, 3313, 3331, 4444,
    14444, 22333, 23233, 23323, 23332, 32233, 32323, 32332,
    33223, 33232, 33322, 41444, 44144, 44414, 44441, 55555,
    122333, 123233, 123323, 123332, 132233, 132323, 132332,
    133223, 133232, 133322, 155555, 212333, 213233, 213323,
    213332, 221333, 223133, 223313, 223331, 224444, 231233,
    231323, 231332, 232133, 232313, 232331, 233123, 233132,
    233213, 233231, 233312, 233321, 242444, 244244, 244424,
    244442, 312233, 312323, 312332, 313223, 313232, 313322,
    321233, 321323, 321332, 322133, 322313, 322331, 323123,
    323132, 323213, 323231, 323312, 323321, 331223, 331232,
    331322, 332123, 332132, 332213, 332231, 332312, 332321,
    333122, 333212, 333221, 422444, 424244, 424424, 424442,
    442244, 442424, 442442, 444224, 444242, 444422, 515555,
    551555, 555155, 555515, 555551, 666666, 1224444}

func nextBeautifulNumber(n int) int {
    return balance[sort.SearchInts(balance, n + 1)]
}
```

```c
const int balance[] = {
    1, 22, 122, 212, 221, 333, 1333, 3133, 3313, 3331, 4444,
    14444, 22333, 23233, 23323, 23332, 32233, 32323, 32332,
    33223, 33232, 33322, 41444, 44144, 44414, 44441, 55555,
    122333, 123233, 123323, 123332, 132233, 132323, 132332,
    133223, 133232, 133322, 155555, 212333, 213233, 213323,
    213332, 221333, 223133, 223313, 223331, 224444, 231233,
    231323, 231332, 232133, 232313, 232331, 233123, 233132,
    233213, 233231, 233312, 233321, 242444, 244244, 244424,
    244442, 312233, 312323, 312332, 313223, 313232, 313322,
    321233, 321323, 321332, 322133, 322313, 322331, 323123,
    323132, 323213, 323231, 323312, 323321, 331223, 331232,
    331322, 332123, 332132, 332213, 332231, 332312, 332321,
    333122, 333212, 333221, 422444, 424244, 424424, 424442,
    442244, 442424, 442442, 444224, 444242, 444422, 515555,
    551555, 555155, 555515, 555551, 666666, 1224444
};

int nextBeautifulNumber(int n) {
    int left = 0, right = sizeof(balance) / sizeof(balance[0]) - 1;
    while (left < right) {
        int mid = (left + right) >> 1;
        if (balance[mid] <= n) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return balance[left];
}
```

```csharp
public class Solution {
    private static int[] balance = new int[] {
        1, 22, 122, 212, 221, 333, 1333, 3133, 3313, 3331, 4444,
        14444, 22333, 23233, 23323, 23332, 32233, 32323, 32332,
        33223, 33232, 33322, 41444, 44144, 44414, 44441, 55555,
        122333, 123233, 123323, 123332, 132233, 132323, 132332,
        133223, 133232, 133322, 155555, 212333, 213233, 213323,
        213332, 221333, 223133, 223313, 223331, 224444, 231233,
        231323, 231332, 232133, 232313, 232331, 233123, 233132,
        233213, 233231, 233312, 233321, 242444, 244244, 244424,
        244442, 312233, 312323, 312332, 313223, 313232, 313322,
        321233, 321323, 321332, 322133, 322313, 322331, 323123,
        323132, 323213, 323231, 323312, 323321, 331223, 331232,
        331322, 332123, 332132, 332213, 332231, 332312, 332321,
        333122, 333212, 333221, 422444, 424244, 424424, 424442,
        442244, 442424, 442442, 444224, 444242, 444422, 515555,
        551555, 555155, 555515, 555551, 666666, 1224444
    };

    public int NextBeautifulNumber(int n) {
        int i = Array.BinarySearch(balance, n + 1);
        if (i < 0) {
            i = -i - 1;
        }
        return balance[i];
    }
}
```

**复杂度分析**

-   时间复杂度：$O(log C)$，其中 $C =110$ 是数值平衡数的个数，取决于题目的数据范围。
-   空间复杂度：$O(C)$，其中 $C =110$ 是数值平衡数的个数，取决于题目的数据范围。
