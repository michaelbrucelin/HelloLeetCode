### 二分法 + 单调数组（类单调栈）

题目翻译，对于数组第i项，向后找到第一个更大的项j，统计以第i+1为第1项，第j项为最后一项，单调递增的子序列的长度

#### 思路

1. 暴力查找需要$O(n^2)$的时间，由题目的数量级知会TLE，所以想到预处理或者计算每一项时充分利用前面已知项的结果
2. 数组后面添加新的项，可能会改变前面所有项的结果，而如果数组前面添加新的项，并不会影响后面所有项的结果，所以考虑从后向前逐项计算

#### 示例

> 数组：`[10, 6, 8, 5, 11, 9]`

1. 初始化
    - 结果数组：`result: [0]`
    - 单调数组：`stack:  [9]`
2. 遍历倒数第2项$11$
    - 在单调数组中找到最后一个大于$11$的项，id为$-1$（二分查找会越界），即单调数组中的值全部小于$11$，所以结果为单调数组的长度$1$
        `result: [1, 0]`
    - 将单调数组从末端开始，所有小于$11$的项移除，将$11$追加到单调数组的末端
        **由于已知单调数组中的值全部小于$11$，所以可以直接清空单调数组**
        `stack:   [11]`
3. 遍历倒数第3项$5$
    - 在单调数组中找到最后一个大于$5$的项，id为$0$，所以结果为$stack.Count-id=1$
        `result: [1, 1, 0]`
    - 将单调数组从末端开始，所有小于$5$的项移除，将$5$追加到单调数组的末端
        **由于已知$5$应该插入的位置，所以可以直接更新那个位置的值，并使用一个`cnt`变量维护单调数组的长度，下同**
        `stack:  [11, 5]`
4. 遍历倒数第4项$8$
    - 在单调数组中找到最后一个大于$8$的项，id为$0$，所以结果为$stack.Count-id=2$
        `result: [2, 1, 1, 0]`
    - 将单调数组从末端开始，所有小于$8$的项移除，将$8$追加到单调数组的末端
        `stack:  [11, 8]`
5. 遍历倒数第5项$6$
    - 在单调数组中找到最后一个大于$6$的项，id为$1$，所以结果为$stack.Count-id=1$
        `result: [1, 2, 1, 1, 0]`
    - 将单调数组从末端开始，所有小于$6$的项移除，将$6$追加到单调数组的末端
        `stack:  [11, 8, 6]`
6. 遍历倒数第6项$10$
    - 在单调数组中找到最后一个大于$10$的项，id为$0$，所以结果为$stack.Count-id=3$
        `result: [3, 1, 2, 1, 1, 0]`
    - 将单调数组从末端开始，所有小于$10$的项移除，将$10$追加到单调数组的末端
        `stack:  [11, 10]`
