#### 分析

1. 预处理字符串每个字符的数量及其连续分布情况，例如：
    ```C
    "aaabbaaa" --> freq = a:6, b:2                // 每个字符的数量
                   dist = (0, 2), (3, 4), (5, 7)  // 连续分布情况
    ```
2. 先处理两种特殊情况
    - 如果字符串只有$1$种字符，那么直接返回整个**字符串的长度**
    - 如果字符串只有$2$种字符，且其中的1种字符只有$1$个，那么直接返回整个**字符串的长度-1**
3. 遍历字符串的**连续分布情况**，遍历到任何一个元组（这里假定是`(l, r)`，对应的字符是`x`），可以快速的知道字符串中`x`的数量`cnt = freq['x']`，以及当前位置连续的`x`的数量`cnt1 = r-l+1`
    - 如果`cnt1 == cnt`，那么调整后仍然是`cnt1`
    - 如果`cnt1 < cnt`
        - 如果调整左侧
            - 如果`str[l-2] != x`，调整后为`cnt1+1`
            - 如果`str[l-2] == x`，那么`str[l-2]`属于`x`的前一个连续区间，假定`x`的数量为`cnt2`
                - 如果`cnt1 + cnt2 != cnt`，调整后为`cnt1 + cnt2 + 1`
                - 如果`cnt1 + cnt2 == cnt`，调整后为`cnt1 + cnt2`
        - 如果调整右侧
            - 如果`str[r+2] != x`，调整后为`cnt1+1`
            - 如果`str[r+2] == x`，那么`str[r+2]`属于`x`的后一个连续区间，假定`x`的数量为`cnt2`
                - 如果`cnt1 + cnt2 != cnt`，调整后为`cnt1 + cnt2 + 1`
                - 如果`cnt1 + cnt2 == cnt`，调整后为`cnt1 + cnt2`
    取上面几个值的最大值，就是此次调整后的最大值
4. 特殊情况不需要单独处理
