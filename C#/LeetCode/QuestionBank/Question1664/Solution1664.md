#### 预处理

我们可以构造一个预处理数组来得到结果。

**示例**
数组`[2, 1, 6, 4]`，我们构造如下数组，即从“当前位到数组结尾奇数位的和与偶数位的和的数组”。
```txt
 [2, 1, 6, 4]
[[8, 5, 6, 4, 0]   // odd， 当前位往后的奇数位和数组，最后一个元素0是哨兵
 [5, 6, 4, 0, 0]]  // even，当前位往后的偶数位和数组，最后一个元素0是哨兵
```

当构造出上面的数组后，我们就可以逐位开始分析
1. 去掉第1（`index=0`）位的2
    - 直接比较`odd[1]`与`even[1]`即可
2. 去掉第2（`index=1`）位的1
    - 第2位为偶数位
        - 所以第2位前面的奇数和为：`odd[0]-odd[2]`即`odd[0]-odd[index+1]`，偶数和为：`even[0]-even[2]-nums[1]`即`even[0]-even[index+1]-nums[index]`
        - 所以去掉第2位后数组的奇数和为：`odd[0]-odd[index+1]+even[index+1]`，偶数和为：`even[0]-even[index+1]-nums[index]+odd[index+1]`
        - 所以去掉第2位后数组的奇数和为：`8-6+4=6`，偶数和为：`5-4-1+6=6`
3. 去掉第3（`index=2`）位的6
    - 第3位为奇数位
        - 所以第3位前面的奇数和为：`odd[0]-odd[2]`即`odd[0]-odd[index]`，偶数和为：`even[0]-even[2]`即`even[0]-even[index]`
        - 所以去掉第3位后数组的奇数和为：`odd[0]-odd[index]+odd[index+1]`，偶数和为：`even[0]-even[index]+even[index+1]`
        - 所以去掉第3位后数组的奇数和为：`8-6+4=6`，偶数和为：`5-4+0=1`
4. 以此类推

**那么下面需要解决的就是如何构造上面的预处理数组了**

其实很简单，从后向前依次处理即可。其中`odd[len] = 0, evev[len] = 0, odd[i] = even[i+1] + nums[i], evev[i] = odd[i+1]`
推演一下数组`[2, 1, 6, 4]`就明白了。
