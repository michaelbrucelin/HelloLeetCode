#### 借助栈分析

结合例子讲解。

`s = "aababbab"`，将输入的`s`整理为下面的栈：

```txt
(a, 2,-1)
(b, 1, 2)  (1, 2)
(a, 1,-1)
(b, 2, 1)  (2, 1)
(a, 1,-1)
(b, 1, 0)  (1, 0)
```

代码需要用的是右边的栈，左边的栈只是为了让右边的栈看起来更清晰，其中元组的第一项是连续的`b`的数量，元组的第二项是这组连续的`b`后面总共有多少个`a`。
这个栈从后向前遍历一次字符串即可轻松获得，下面讲一下怎样用这个栈来得到结果。

步骤：
声明变量：`int result = s.Length, temp = 0;`

1. 弹栈，`(1, 2)`，表示这组一共有$1$个`b`，后面总共有$2$个`a`
    1. 如果这组`b`保留，那么需要把这组`b`后面的`a`全部删除，需要$2$步，这是一个候选结果，`result = Math.Min(result, 2);`
    2. 如果这组`b`删除，那么需要操作$1$步，这是一个中间结果，`temp += 1;  // temp: 1`
2. 弹栈，`(2, 1)`，表示这组一共有$2$个`b`，后面总共有$1$个`a`
    1. 如果这组`b`保留，那么需要把这组`b`后面的`a`全部删除，需要$1$步，再算上前面的中间结果总共需要$2$步，这是一个候选结果，`result = Math.Min(result, 2);`
    2. 如果这组`b`删除，那么需要操作$2$步，这是一个中间结果，`temp += 2;  // temp: 3`
3. 弹栈，`(1, 0)`，表示这组一共有$1$个`b`，后面总共有$0$个`a`
    1. 如果这组`b`保留，那么需要把这组`b`后面的`a`全部删除，需要$0$步，再算上前面的中间结果总共需要$3$步，这是一个候选结果，`result = Math.Min(result, 3);`
    2. 如果这组`b`删除，那么需要操作$1$步，这是一个中间结果，`temp += 1;  // temp: 4`
4. 栈空，合并一下中间结果：`result = Math.Min(result, temp);`
