#### 动态规划

**<span style='color:red'>如果得分一样，没有办法确认哪个成本更低，例如"a1b1c1"与"d1e1f1"不能说哪个成本低，哪个成本高，所以下面的描述是错误的。</span>**

首先定义数组的**加|减法**与**比较大小**（这里用的数组是固定长度：26），**加|减法**即**数组的每一个位置相加|减**，**比较大小**即**每一个位置比较大小，类似于字符串比较大小**。

**示例1**
words = ["dog","cat","dad","good"]
letters = ["a","a","c","d","d","d","g","o","o"]
score = [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0]

整理为（为了看着清楚，这里$0$用空格表示）

```txt
            a b c d e f g h i j k l m n o p q r s t u v w x y z
"dog":     [ , , ,1, , ,1, , , , , , , ,1, , , , , , , , , , , ], point: 10
"cat":     [1, ,1, , , , , , , , , , , , , , , , ,1, , , , , , ], point: 10
"dad":     [1, , ,2, , , , , , , , , , , , , , , , , , , , , , ], point: 11
"good":    [ , , ,1, , ,1, , , , , , , ,2, , , , , , , , , , , ], point: 12
"letters"：[2, ,1,3, , ,1, , , , , , , ,2, , , , , , , , , , , ]
```

下面开始DP
|  | `null` | "dog" | "cat" | "dad" | "good" |
| -- | -- | -- | -- | -- | -- |
| `[2, , , , , , , , , , , , , , , , , , , , , , , , , ] a2c0d0g0o0` | `a0c0d0g0o0` 0 | `a0c0d0g0o0` 0 | `a0c0d0g0o0` 0 | `a0c0d0g0o0` 0 | `a0c0d0g0o0` 0 |
| `[2, ,1, , , , , , , , , , , , , , , , , , , , , , , ] a2c1d0g0o0` | `a0c0d0g0o0` 0 | `a0c0d0g0o0` 0 | `a0c0d0g0o0` 0 | `a0c0d0g0o0` 0 | `a0c0d0g0o0` 0 |
| `[2, ,1,3, , , , , , , , , , , , , , , , , , , , , , ] a2c1d3g0o0` | `a0c0d0g0o0` 0 | `a0c0d0g0o0` 0 | `a0c0d0g0o0` 0 | `a0c0d0g0o0` 0 | `a0c0d0g0o0` 0 |
| `[2, ,1,3, , ,1, , , , , , , , , , , , , , , , , , , ] a2c1d3g1o0` | `a0c0d0g0o0` 0 | `a0c0d0g0o0` 0 | `a0c0d0g0o0` 0 | `a1c0d2g0o0`11 | `a0c0d0g0o0` 0 |
| `[2, ,1,3, , ,1, , , , , , , ,2, , , , , , , , , , , ] a2c1d3g1o2` | `a0c0d0g0o0` 0 | `a0c0d1g1o1`10 | `a0c0d1g1o1`10 | `a1c0d3g1o0`21 | `a1c0d3g1o2`23 |

这里简单解释一下上面的表格，例如最后一行倒数第二列的$21$分时怎么来的？

1. 这一列的word是"dad"，这个word只有用与不用两种可能
    - 不用，那么得分就是左边的得分：$10$
    - 用，
        - 首先，检查资源够不够用，发现够用，所以可以得到分数：$11$，剩余资源：`a1c1d1g1o2`（资源：`a2c1d3g1o2`，消耗`a1d2`）
        - 剩余资源是`a1c1d1g1o2`，现在要解决的就是找到剩余资源在左边一列可以得到的最高分：$10$（**可不可以用二分法？没想明白，这里从下向上逐个查找**）
        - 所以，总得分：$21$
