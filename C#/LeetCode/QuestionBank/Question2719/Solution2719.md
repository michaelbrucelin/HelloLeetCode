### 容斥原理 + 分类讨论

#### 1、拆解问题

首先将问题拆解，

```C
    [num1, num2] -> x -> [min, max]
=== [0, num2] -> x -> [min, max]                              -  [0, num1-1] -> [min, max]
=== [0, num2] -> x -> [0, max] - [0, num2] -> x -> [0, min-1] - ([0, num1-1] -> x -> [0, max] - [0, num1-1] -> x -> [0, min-1])
```

令 `F(num, sum) = Count(x <= num && digit_sum(x) <= sum)`，则：

```C
Count(num1, num2, min_sum, max_sum) = F(num2,   max_sum)
                                    - F(num2,   min_sum-1)
                                    - F(num1-1, max_sum)
                                    - F(num1-1, min_sum-1)
```

这样就将问题拆解的更简单了。

#### 2、预处理

**<span style='color:red'>如果在生产环境中，可以提前预处理好这个分布数组，没必要每次都处理一遍。</span>**

然后，预处理出不同长度的数字（含前导`0`）的`digit_sum`的分布，可以用一个整型数组表示，索引是`digit_sum`，值是对应`digit_sum`的整数的数量。

1位数字，即`0 ~ 9`，    一共有10种可能，     分布为`[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]`
2位数字，即`00 ~ 99`，  一共有19种可能，     分布为`[ ... ... ]`
3位数字，即`000 ~ 999`，一共有28种可能，     分布为`[ ... ... ]`
... ...
k位数字，即`... ~ ...`，一共有`k*9+1`种可能，分布为`[ ... ... ]`

下面分析怎样可以快速得到所有的分布。
假设k位数字的分布已知`dist_k`，那么怎样得到k+1位数字的分布呢？k+1数字可以看作是k位数字前面分别补了`0 ~ 9`得到的

```C
int len_k = k*9+1, len_k1 = (k+1)*9+1;
for(int i = 0; i < 10; i++) {
    for(int j = 0; j < len_k; j++) {
        dist_k1[j+i] += dist_k[j] + i;
    }
}
```

为了下面方便，`dist`数组可以继续预处理为前缀和形式。

#### 3、 分类讨论

下面以`num = 32768, sum = 16`来举例说明如何进行分类讨论。

- 讨论第1位
  - 第1位取0，有`dist_4[16]`种可能
  - 第1位取1，有`dist_4[16-1]`种可能
  - 第1位取2，有`dist_4[16-2]`种可能
- 第1位取3，讨论第2位
  - 第2位取0，有`dist_3[16-3]`种可能
  - 第2位取1，有`dist_3[16-3-1]`种可能
- 前2位取32，讨论第3位
  - 第3位取0，有`dist_3[16-3-2]`种可能
  - 第3位取1，有`dist_3[16-3-2-1]`种可能
  - ... ...
  - 第3位取6，有`dist_3[16-3-2-6]`种可能
- ... ...

这样就可以计算出结果了。
